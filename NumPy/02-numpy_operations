import numpy as np
from numpyhelpers import printnp, time_f

# Arithmetic operations are applied elementwise. A new array is created and filled with the result
a = np.array([10, 20, 30, 40])
printnp(a)
b = a - 1
printnp(b)
c = b * a
printnp(c)

# Do matrix multiplication with @
first = np.array([[1, 1], [0, 1]])
second = np.array([[2, 0], [3, 4]])
printnp(first @ second)

#Some operators Ilke or WII I act in place to modify an array rather than generate a new one
ones = np.ones((2, 6))
printnp(ones)
one_two = np.array([1, 2, 1, 2, 1, 2])
printnp(one_two)

ones *= one_two
printnp(ones)

# Note that this is a case of "broadcasting" if the arrays are not of the same size,
# the smalleris "broadcast" across the larger array. This actually what happens if you use a constant!
print(ones + 10)

# When can you broadcast?
# You can broadcast when each dimension in both arrays are equal, or one of the dimensions is 1, matching from the *right*
# Missing dimensions are assumed to be 1

incompatible = np.array([
    [
        [1], [10], [100], [1000], [1000]
    ],
    [
        [1],[1],[1],[1],[1]
    ],
])
printnp(incompatible)
# This will not work! ones is treated as because it has one less dimension,
# and isn't compatible with (2,6,1)
# print(ones + incompatible)

# If we operate on arrays of different types, the result is going to get upcast to the more general or precise one
int_array = np.array([1,2,3], dtype="int64")
small_int_array = np.array([4,5,6], dtype="int8")
printnp(int_array)
printnp(small_int_array)
printnp(int_array + small_int_array)
float_array = np.array([7,8,9], dtype="float")

printnp(int_array * float_array)

# There are some functions whcih operate on a whole array
numbers = np.array([[1,2,3,4,5], [10,20,30,40,50]])
print("Numbers: ")
printnp(numbers)
print(numbers.sum())
# ndarray.sum is equivilent to numpy.sum(ndarray)
print(np.sum(numbers))

print(numbers.flatten())

print(f"Sum on axis 0: {numbers.sum(axis=0)}")
print(f"Sum on axis 1: {numbers.sum(axis=1)}")

# There are lots and lots of numpy functions - most of which operate elementwise, but some operate on while arrays
# If you're looking for a mathematical function, it's probably

# There's a whole class of functions called "ufunc"s or universal functions which opperate on ndarrays,
# in an element-by-element fashion
numbers = np.array([[60, -1, 20], [-22, 545, -292]])
print(np.abs(numbers))

# You can use as type to try and convert between types for an entitre array
string_as_numbers = np.array(['242','532','3425','22','41'])
printnp(string_as_numbers)
numbers = string_as_numbers.astype("int32")
printnp(numbers)

# What if none of numpy's default functions fit? 

def add_3(number):
    return number + 3

print(add_3(7))
print(add_3(numbers))

def double_odd_numbers(number):
    if number % 2 == 0:
        return number
    else:
        return number * 2
    
print(double_odd_numbers(7))
print(double_odd_numbers(6))
#print(double_odd_numbers(numbers))

# You can vectorize a fucntion to change it to a function that when you pass in an array it runs the fucntion on each elelment individually 
vectorized_double_odd_numbers = np.vectorize(double_odd_numbers)
print(vectorized_double_odd_numbers(numbers))

thousand = np.arange(1000)
def sum_array(array):
    return array.sum()

result = time_f(sum_array, (thousand))
print(result)